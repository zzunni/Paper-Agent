

===== Page 1 =====

Differentiable Edge-based OPC
Guojin Chenâˆ—
CUHK & UT Austin & NVIDIA
Haoyu Yang
NVIDIA Corporation
Haoxing Ren
NVIDIA Corporation
Bei Yu
Chinese University of Hong Kong
David Z. Pan
University of Texas at Austin
Abstract
Optical proximity correction (OPC) is crucial for pushing the
boundaries of semiconductor manufacturing and enabling the continued scaling of integrated circuits. While pixel-based OPC, termed
as inverse lithography technology (ILT), has gained research interest
due to its flexibility and precision. Its complexity and intricate features can lead to challenges in mask writing, increased defects, and
higher costs, hence hindering widespread industrial adoption. In this
paper, we propose DiffOPC, a differentiable OPC framework that
enjoys the virtue of both edge-based OPC and ILT. By employing
a mask rule-aware gradient-based optimization approach, DiffOPC
efficiently guides mask edge segment movement during mask optimization, minimizing wafer error by propagating true gradients from
the cost function back to the mask edges. Our approach achieves
lower edge placement error while reducing manufacturing cost by
half compared to state-of-the-art OPC techniques, bridging the gap
between the high accuracy of pixel-based OPC and the practicality
required for industrial adoption, thus offering a promising solution
for advanced semiconductor manufacturing.
1
Introduction
Optical proximity correction (OPC) is a critical technique in computational lithography that compensates for the optical proximity
effect (OPE) caused by interference and diffraction in the lithographic
imaging process. As integrated circuit technology nodes advance
to 90 nm and below, simple resolution enhancement techniques
(RET) can no longer meet the requirements for high-resolution and
high-fidelity lithographic imaging. To address this challenge, OPC
has evolved from rule-based OPC (RBOPC) to model-based OPC
(MBOPC).
RBOPC relies on a pre-established mask correction rule table,
which is derived from engineering experience or fitted experimental
and simulation data [1]. Although RBOPC is computationally fast
and produces relatively simple optimized mask patterns, it can only
compensate for local OPE and cannot find a globally optimal solution
for the mask optimization problem.
MBOPC, on the other hand, is based on the physical model of lithographic imaging and employs numerical optimization algorithms
to modify the mask pattern. As depicted in Figure 1, MBOPC can
be further classified into edge-based OPC (EBOPC) and pixel-based
OPC (PBOPC). EBOPC divides the edge contour of the mask pattern
into several segments and iteratively optimizes the position of each
segment along its normal direction to compensate for lithographic
imaging errors [2].
However, current EBOPC methods, such as the Mask Error Enhancement Factor (MEEF) matrix algorithm [2], have limitations in
âˆ—Work accomplished during internship at NVIDIA.
PBOPC
(ILT)
SRAFs
MRC violations
Pxiel-based ILT
Level set-based ILT
MRC violations
EBOPC
Traditional
MEEF-based EBOPC
DiffOPC (Ours)
SRAFs
EPE: 25
EPE: 51
MRC clean
MRC clean
EPE: 59
EPE: 19
Figure 1: Model-based OPC includes pixel-based OPC (ILT)
and edge-based OPC (EBOPC). While ILT masks face manufacturability issues requiring significant post-processing, EBOPC
masks are manufacturable but have performance limitations.
DiffOPC combines the advantages of both approaches, enhancing manufacturability and performance.
computational efficiency and accuracy. The algorithm is computationally intensive, scaling poorly with the size and complexity of IC
layouts. Its foundational linearity assumptions often fail to account
for the nonlinearities prevalent in advanced lithography, leading to
subpar performance in complex cases where edge interactions are
significant and not adequately captured. The MEEF matrix, further
burdened by potential ill-conditioning and a static representation
throughout optimization, may not adapt to dynamic process variations, thus trading off accuracy for computational manageability.
PBOPC, also known as inverse lithography technology (ILT),
pushes the boundaries of mask optimization by rasterizing the mask
layout into a pixel array and optimizing the transmission of each
mask pixel by gradient descent [3]. This approach allows for freeform curved edge contours and the addition of sub-resolution assist
features (SRAF) [4â€“7] to improve imaging performance. ILT algorithms can be categorized into two classes based on their mask
representation: end-to-end pixel-based methods for prediction [8â€“
14] or acceleration, and implicit function-based methods using level
sets to enhance acceleration and manufacturability [15â€“17]. Among
the SOTA ILT methods, MultiILT [14] adopts a multi-level resolution
strategy for better OPC performance and manufacturability.
Despite the advancements in ILT algorithms, they still face several
challenges that hinder their widespread adoption in the semiconductor industry. As illustrated in Figure 1, the pixelated mask patterns
generated by ILT are often complex and difficult to manufacture,
requiring costly rectangular decomposition into manufacturable
arXiv:2408.08969v3  [cs.AI]  30 Aug 2024

===== Page 2 =====

Manhattan polygons. Further, the application of decomposition and
mask rule check (MRC) methods to regularize the mask patterns may
lead to a decline in OPC performance and introduce new hotspots,
negating the performance advantages of ILT. Moreover, ILT algorithms tend to over-optimize shape corners because the simulated
line-ends will never match the Manhattan rectangles at the line-end.
Nevertheless, these challenges have been largely overlooked, preventing ILTâ€™s large-scale adoption in the industry, which tends to
favor EBOPC due to lower manufacturing costs.
To bridge the gap between the manufacturability of EBOPC and
the performance of ILT, we propose DiffOPC, a differentiable edgebased OPC method that leverages gradient information to optimize
edge placement error (EPE) while considering process variation. By
relaxing discrete edge movements and embedding mask rule constraints into the gradient computation, DiffOPC combines EBOPCâ€™s
high manufacturability with ILTâ€™s performance. Additionally, it ensures MRC-clean results, allowing the optimized mask patterns
to be directly used for mask fabrication without additional postprocessing.
DiffOPC introduces efficient solutions to enhance the edge-based
OPC process. In the forward algorithm, a flexible segmentation approach and CUDA-accelerated ray casting expedite differentiable
layout rasterization, while a novel SRAF seed generation algorithm
optimizes SRAF placement. In the backward algorithm, DiffOPC computes lithography gradients for edge movements using a chain-rule
approach and incorporates mask rule constraints to ensure manufacturability. By combining these improvements, DiffOPC achieves
superior OPC performance with high manufacturability. In summary,
our main contributions are as follows:
â€¢ We propose DiffOPC, a differentiable edge-based OPC framework that integrates EPE loss and leverages MRC-aware gradients for mask optimization.
â€¢ A flexible segmentation approach and a CUDA-accelerated ray
casting algorithm are introduced to expedite layout rasterization.
â€¢ DiffOPC efficiently computes edge segment gradients using a
chain-rule approach to ensure manufacturability.
â€¢ A novel SRAF seed generation algorithm leveraging gradients
for optimal SRAF placement and further optimization.
â€¢ DiffOPC bridges the gap between EBOPCâ€™s manufacturability
and ILTâ€™s performance, offering a promising solution for highquality and efficient OPC corrections. The experimental results
show that DiffOPC reduces EBOPCâ€™s EPE by half, and even
achieves lower EPE than ILT while maintaining manufacturing
costs that are half of ILTâ€™s.
2
Preliminaries
2.1
Forward Lithography Model
We employ the sum of coherent systems (SOCS) decomposition
of a 193ğ‘›ğ‘šwavelength system as the optical model for lithography
modeling, following the same approach as [18]. The aerial image
intensity ğ‘°is represented by the convolution of the mask ğ‘´and a set
of optical kernels ğ‘¯. The ğ‘ğ‘¡â„
ğ‘˜
order approximation to the partially
coherent system is obtained using eq. (1):
ğ‘°(ğ‘¥,ğ‘¦) â‰ˆ
ğ‘ğ‘˜
âˆ‘ï¸
ğ‘–=1
ğœğ‘–|ğ‘´(ğ‘¥,ğ‘¦) âŠ—â„ğ‘–(ğ‘¥,ğ‘¦)|2 ,
(1)
where âŠ—denotes the convolution operation, â„ğ‘–is the ğ‘–ğ‘¡â„kernel of ğ‘¯,
ğœğ‘–is the corresponding weight of the coherent system, and (ğ‘¥,ğ‘¦) is
the index notation of the matrix. ğ‘´(ğ‘¥,ğ‘¦) represents the pixel value
at the point (ğ‘¥,ğ‘¦) of the mask image ğ‘´. A constant threshold resist
model (CTR) is applied to convert the aerial image intensity ğ‘°to the
printed resist image ğ’.
ğ’(ğ‘¥,ğ‘¦) =
 1,
if ğ‘°(ğ‘¥,ğ‘¦) > ğ¼ğ‘¡â„,
0,
otherwise,
(2)
where ğ¼ğ‘¡â„is the intensity threshold.
2.2
Evaluation Metrics
In this paper, we use squared ğ¿2 error, process variation band
(PVB) and edge placement error (EPE) as three typical metrics to evaluate OPC performance. Moreover, the mask fracturing shot count
(#shot) proposed in [10] is also applied in this work to evaluate mask
complexity and manufacturability.
Squared ğ¿2 error ğ¿2 measures the difference between the nominal
resist image ğ’ğ‘›ğ‘œğ‘šand the target image ğ‘», defined as:
ğ¿2(ğ’ğ‘›ğ‘œğ‘š, ğ‘») = âˆ¥ğ’ğ‘›ğ‘œğ‘šâˆ’ğ‘»âˆ¥2
2.
(3)
PVB evaluates the robustness of the mask against different process conditions. A smaller PVB indicates a more robust mask.
PVB(ğ’ğ‘šğ‘ğ‘¥, ğ’ğ‘šğ‘–ğ‘›) = âˆ¥ğ’ğ‘šğ‘ğ‘¥âˆ’ğ’ğ‘šğ‘–ğ‘›âˆ¥2
2.
Edge placement error The Edge Placement Error (EPE) [18] quantifies the geometric distortion of the resist image.
Shot count #Shot [10] is the number of decomposed rectangles
that replicate the original mask exactly.
2.3
Problem Formulation
Given a target design ğ‘», we aim to find a set of boundary segments
ğ‘º= {ğ’”1, ğ’”2, . . . , ğ’”ğ‘–}, and a binary mask ğ‘´âˆˆ{0, 1}ğ‘šÃ—ğ‘›formed by the
matrix inside the boundary composed of these segments ğ‘º, where
ğ‘šand ğ‘›are the dimensions of ğ‘». The objective is to determine the
corresponding printed image ğ’that minimizes the weighted sum of
EPE, ğ¿2, PVB, and #shots.
3
DiffOPC Algorithm
To enable the application of differentiable EBOPC to arbitrary
layout patterns while utilizing minimal additional information, such
as the EPE measure points, several challenges need to be addressed:
1) Ensuring a more flexible movement of segments in Manhattan
geometries, particularly at pattern corners. 2) Mapping discrete edge
movements to a continuous space for efficient updates. 3) Maintaining compatibility with the chain rule for differentiation during the
rasterization process, which converts edge parameters to pixel binary masks. In this section, we introduce the movement and update
mechanisms for edge segments, describe a CUDA-accelerated ray
casting algorithm for rasterization, demonstrate how lithography
gradients can be utilized to update the movement of edge segments,
and introduce an algorithm for SRAF placement.
3.1
Edge Segmentation and Movement
We present Algorithm 1 for segmenting target polygon edges into
smaller segments of a pre-defined length. The algorithm returns a
minimal set of segments, denoted as ğ‘ºâˆˆRğ‘ğ‘ Ã—2Ã—2, where R represents the real number domain and ğ‘ğ‘ is the number of segments.
Each segment ğ’”ğ‘–âˆˆğ‘ºis represented by its starting and ending coordinates in vector form: [[ğ‘¥1,ğ‘¦1], [ğ‘¥2,ğ‘¦2]]. These segments ğ‘ºserve

===== Page 3 =====

Initial Segments
 Optimized Segments
Mask gradient
Mask
Resist
Initialize
Update
STE
Corner Merge
Rasterization
Forward 
Lithography
Lithography
Gradient
Calculate Loss
Gradient
Interpolation
GDS
OASIS
Layout
Corner Segments
Horizontal & Vertical
Segments
DiffOPC Forward
DiffOPC Backward
Segment Gradients & Velocities
Figure 2: DiffOPC: differentiable edge-based OPC framework.
as the optimization parameters for DiffOPC, providing increased
flexibility in handling corner edges compared to traditional EBOPC
methods which only optimize the edge movement distance. As illustrated in Figure 2, each segment ğ’”ğ‘–is associated with a direction
vector ğ’…ğ‘–âˆˆD, which enables better reconstruction of segments back
into polygons and determines the direction of movement. Furthermore, the algorithm ensures compliance with the MRC by merging
excessively short segments when necessary.
Algorithm 1 Edge Parameter Initialization.
Input: ğ‘ğ‘œğ‘™ğ‘¦ğ‘”ğ‘œğ‘›ğ‘ : mask polygon coordinates; ğ‘ ğ‘’ğ‘”_ğ‘™ğ‘’ğ‘›ğ‘”ğ‘¡â„: segment length.
Output: ğ‘ğ‘™ğ‘™_ğ‘ ğ‘’ğ‘”ğ‘šğ‘’ğ‘›ğ‘¡ğ‘ : List of polygons with segmented lines & directions;
1: for ğ‘ğ‘œğ‘™ğ‘¦in ğ‘ğ‘œğ‘™ğ‘¦ğ‘”ğ‘œğ‘›ğ‘ do
2:
for ğ‘’ğ‘‘ğ‘”ğ‘’in ğ‘ğ‘œğ‘™ğ‘¦do
3:
ğ‘šğ‘–ğ‘‘ğ‘ğ‘œğ‘–ğ‘›ğ‘¡â†Calculate the midpoint of the edge;
4:
ğ‘™ğ‘’ğ‘›ğ‘”ğ‘¡â„â†Calculate the length of the edge;
5:
ğ‘‘ğ‘–ğ‘Ÿğ‘’ğ‘ğ‘¡ğ‘–ğ‘œğ‘›â†Get edge direction vector (horizontal or vertical);
6:
if ğ‘™ğ‘’ğ‘›ğ‘”ğ‘¡â„â‰¤2 âˆ—ğ‘ ğ‘’ğ‘”_ğ‘™ğ‘’ğ‘›ğ‘”ğ‘¡â„then
7:
Create two segments from ğ‘šğ‘–ğ‘‘ğ‘ğ‘œğ‘–ğ‘›ğ‘¡;
8:
else
9:
ğ‘ ğ‘¡ğ‘’ğ‘ğ‘ â†Calculate the number of steps based on edge ğ‘™ğ‘’ğ‘›ğ‘”ğ‘¡â„
and ğ‘ ğ‘’ğ‘”_ğ‘™ğ‘’ğ‘›ğ‘”ğ‘¡â„;
10:
for ğ‘–â†âˆ’ğ‘ ğ‘¡ğ‘’ğ‘ğ‘ to ğ‘ ğ‘¡ğ‘’ğ‘ğ‘ do
11:
Calculate the start and end points of the segment based
on ğ‘šğ‘–ğ‘‘ğ‘ğ‘œğ‘–ğ‘›ğ‘¡and step size;
12:
if segment length > ğ‘ ğ‘’ğ‘”_ğ‘™ğ‘’ğ‘›ğ‘”ğ‘¡â„then
13:
Split the segment into two segments at theğ‘šğ‘–ğ‘‘ğ‘ğ‘œğ‘–ğ‘›ğ‘¡;
14:
else
15:
Create a single segment;
16:
Mark the start or the end of edge segments as corner segments;
17:
Add the segments and directions to polygon segments list;
18:
Add the polygon segments and directions to ğ‘ğ‘™ğ‘™_ğ‘ ğ‘’ğ‘”ğ‘šğ‘’ğ‘›ğ‘¡ğ‘ ;
19: return ğ‘ğ‘™ğ‘™_ğ‘ ğ‘’ğ‘”ğ‘šğ‘’ğ‘›ğ‘¡ğ‘ ;
In DiffOPC, after determining the segments ğ‘ºand their corresponding directions D, it is crucial to establish the velocity vector ğ’—ğ‘–
for each segment ğ’”ğ‘–. The velocity vector connects the movement of
edge segments with the gradients obtained from lithography simulations. The concept of velocity vectors is inspired by level set-based
ILT (LSILT). In LSILT, the velocity component is the projection of
the gradient of the implicit level set function ğœ™onto the mask plane,
denoted as âˆ‡ğœ™, which can be a vector in any direction. However,
in DiffOPC, the movement direction ğ’—ğ‘–of an edge segment ğ’”ğ‘–is
restricted to be perpendicular to its direction vector ğ’…ğ‘–, (either horizontal or vertical), satisfying the condition ğ’—ğ‘–Â· ğ’…ğ‘–= 0. Additionally,
we set the default orientation of all velocity vectors ğ’—ğ‘–to point outward from the polygon, as illustrated in Figure 2.
3.2
Differentiable Edge-Based OPC
The preprocessed data consists of segments ğ‘ºand corresponding velocity vectors ğ‘½. ğ‘ºis stored as learnable parameters in tensor
ğ‘ºâˆˆRğ‘ğ‘ Ã—2Ã—2, while ğ‘½is a fixed tensor ğ‘½âˆˆRğ‘ğ‘ Ã—2 used in computations, where ğ‘ğ‘ is the number of segments. In DiffOPC, the
forward pass from edge parameters ğ‘ºto the resist image ğ’involves
five differentiable steps: 1) Edge parameter rounding. 2) Merging
corner edges. 3) Edge-to-mask rasterization. 4) Forward lithography
simulation. 5) Loss calculation. Each stepâ€™s forward and backward
computations will be discussed in detail in this chapter.
Differentiable edge parameter rounding. Since the edge parameters ğ‘ºare real-valued, while the edge coordinate system is integervalued, the rounding operation is non-differentiable. To address this
issue and enable a differentiable process, we employ the straightthrough estimator (STE) for rounding ğ‘º.
Â¯ğ‘¥ğ‘–= STE(ğ‘¥ğ‘–), Â¯ğ‘¦ğ‘–= STE(ğ‘¦ğ‘–), Â¯ğ’”ğ‘–= STE(ğ’”ğ‘–), Â¯ğ‘º= STE(ğ‘º).
(4)
STE is defined as:
Â¯ğ‘¥= STE(ğ‘¥) = Round(ğ‘¥),
â–·STE forward.
ğœ•ğ¿
ğœ•STE(ğ‘¥) = ğœ•ğ¿
ğœ•ğ‘¥.
â–·STE backward.
(5)
The forward pass illustrated in Figure 3(a) applies the rounding
function to ğ‘º, while the backward pass directly propagates the
gradients from Â¯ğ‘ºto ğ‘º, as shown in Figure 3(b).
1 2 3 4
1
2
3
0
ğ‘¥
STE(ğ‘¥)
(a)
1
2
3
1
2
3
0
ğœ•ğ¿
ğœ•ğ‘¥
ğœ•ğ¿
ğœ•STE(ğ‘¥)
(b)
Figure 3: (a) STE forward; (b) STE backward.
Corner edge merging. During the optimization, as edges move, the
endpoints of different segments separate. For non-corner segments,
the segment length remains unchanged since they only move along

===== Page 4 =====

the normal direction. The newly formed edges between adjacent
segments can be obtained from the endpoints of the neighboring
edges without additional processing. However, for segments adjacent
to corners, the movement directions differ, requiring extra handling.
After the movement, the new intersection point may lie outside
the two segments. Therefore, it is necessary to additionally connect
the segments adjacent to the corners. The adjusted algorithm is
presented in Algorithm 2. After the forward pass of the corner
merging operation, the modified edge parameters Ë†ğ‘ºensure that all
adjacent segments at the corners are re-connected. The backward
pass is straightforward, as the gradients are directly propagated to
the rounded edge parameters Â¯ğ‘º.
Algorithm 2 Find Intersection and Adjust Corner Segments
1: function FindIntersectionAndAdjust(Â¯ğ‘ 1, Â¯ğ‘ 2)
2:
ğ‘ ğ‘£â†vertical segment; ğ‘ â„â†horizontal segment;
3:
ğ‘â€  â†the intersection point (ğ‘¥of ğ‘ ğ‘£, ğ‘¦of ğ‘ â„);
4:
if Â¯ğ‘ 1 is vertical then
5:
Adjust the end point of the vertical line ğ‘ ğ‘£to ğ‘â€ ;
6:
Adjust the start point of the horizontal line ğ‘ â„to ğ‘â€ ;
7:
else
8:
Adjust the end point of the horizontal line ğ‘ â„to ğ‘â€ ;
9:
Adjust the start point of the vertical line ğ‘ ğ‘£to ğ‘â€ ;
10:
return the adjusted segments (Ë†ğ‘ 1, Ë†ğ‘ 2);
Differentiable rasterization using CUDA-accelerated ray casting. The core challenge in DiffOPC is the edge-to-pixel rasterization,
as the lithography model in eq. (1) only accepts pixel-based mask
input ğ‘´. This rasterization process must be differentiable to allow
the gradient flow to reach the edge parameters from the mask, and it
should be as fast as possible since it is performed in every optimization epoch. Traditional EBOPC methods involve moving segments
and then filling or subtracting the corresponding binary matrix at the
new positions. However, this approach is time-consuming due to the
need to sequentially access each segment and convert the segmentâ€™s
displacement into mask indices, repeatedly reading and modifying
the corresponding locations. To address these issues, a method that
effectively generates a binary mask from rounded edge parameters
using CUDA-accelerated ray casting is proposed in Algorithm 3.
Algorithm 3 presents an efficient, fully parallelized method for
generating a binary mask from edge parameters using ray casting.
The main function, Rasterize, initializes an empty mask and a
count matrix, then extracts horizontal segments from the edge parameters. Since the polygons in the mask are Manhattan rectangles
and closed shapes, the algorithm only needs to process segments
along one direction (either horizontal or vertical), reducing the computational cost by half. For each segment, the algorithm performs
parallel computation across all grid points within the bounding box,
calling the check_cross function to determine ray-segment intersections. The check_cross function uses cross products to
efficiently check if a ray from a point intersects a segment. After
processing all segments, the even-odd rule is applied to finalize the
binary mask based on the parity of intersections at each point. The
algorithm leverages parallel computation, efficient ray-segment intersection checks, and the properties of Manhattan rectangles to
enable fast and accurate mask generation, making it suitable for use
in the DiffOPC framework.
Algorithm 3 Parallelized Ray Casting for Edge to Mask Rasterization
Input: Merged edge parameters: Ë†ğ‘º, width ğ‘Š, height ğ»;
Output: Binary mask: ğ‘šğ‘ğ‘ ğ‘˜;
1: function Rasterize(Ë†ğ‘º,ğ‘Š, ğ»)
2:
ğ‘šğ‘ğ‘ ğ‘˜â†zeros((ğ‘Š, ğ»)); ğ‘ğ‘ğ‘œğ‘¥â†bounding_box(Ë†ğ‘º);
3:
ğ‘ğ‘œğ‘–ğ‘›ğ‘¡ğ‘ â†grid_within(ğ‘ğ‘ğ‘œğ‘¥); ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡â†zeros((ğ‘Š, ğ»));
4:
â–·Create grid points and initialize count
5:
Ë†ğ‘ºâ„â†extract horizontal segments from Ë†ğ‘º;
6:
for ğ’”ğ‘–in Ë†ğ‘ºâ„parallelly do
â–·Parallel computation
7:
for ğ‘in ğ‘ğ‘œğ‘–ğ‘›ğ‘¡ğ‘ parallelly do
8:
ğ‘ğ‘Ÿğ‘œğ‘ ğ‘ â†check_cross(ğ‘, ğ’”ğ‘–);
9:
ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡[ğ‘] â†ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡[ğ‘] + ğ‘ğ‘Ÿğ‘œğ‘ ğ‘ â–·Accumulate checks
10:
__syncthreads();
â–·Synchronize threads
11:
ğ‘šğ‘ğ‘ ğ‘˜â†mod(ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡, 2) == 1;
â–·Apply even-odd rule
12:
return ğ‘šğ‘ğ‘ ğ‘˜;
13: function check_cross(ğ‘, ğ‘º)
14:
ğ‘£1 â†ğ‘âˆ’ğ‘ .ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡; ğ‘£2 â†ğ‘âˆ’ğ‘ .ğ‘’ğ‘›ğ‘‘;
â–·Vectors from ğ‘to ğ‘º
15:
ğ‘ğ‘Ÿğ‘œğ‘ ğ‘ â†ğ‘£1.ğ‘¥Ã— ğ‘£2.ğ‘¦âˆ’ğ‘£1.ğ‘¦Ã— ğ‘£2.ğ‘¥;
â–·Cross product
16:
ğ‘ğ‘œğ‘›ğ‘‘1 â†(ğ‘£1.ğ‘¥< 0) and (ğ‘£2.ğ‘¥â‰¥0) and (ğ‘ğ‘Ÿğ‘œğ‘ ğ‘ < 0);
17:
ğ‘ğ‘œğ‘›ğ‘‘2 â†(ğ‘£1.ğ‘¥â‰¥0) and (ğ‘£2.ğ‘¥< 0) and (ğ‘ğ‘Ÿğ‘œğ‘ ğ‘ > 0);
18:
return ğ‘ğ‘œğ‘›ğ‘‘1 or ğ‘ğ‘œğ‘›ğ‘‘2;
â–·True if ray crosses the segment
The forward pass of the rasterization process converts the edge
parameters, represented as a tensor of shape [ğ‘ğ‘ , 2, 2], into a mask
tensor of shape [ğ‘Š, ğ»], where ğ‘ğ‘ is the number of segments, andğ‘Š
and ğ»are the width and height of the mask, respectively. In contrast,
the backward pass requires transforming the gradients from the
lithography model, which are of shape [ğ‘Š, ğ»], into gradients for the
segments, represented as a tensor of shape [ğ‘ğ‘ , 2, 2]. To accomplish
this, the algorithm first computes the gradient of the mask tensor
with respect to the edge parameters using automatic differentiation.
Let ğœ•ğ¿
ğœ•ğ‘´be the gradient of the loss function ğ¿with respect to the
mask tensor ğ‘´, obtained from the lithography model. The goal is
to calculate ğœ•ğ¿
ğœ•Ë†ğ‘º, the gradient of the loss function with respect to the
edge parameters Ë†ğ‘º. Applying the chain rule, we have:
ğœ•ğ¿
ğœ•Ë†ğ‘º
= ğœ•ğ¿
ğœ•ğ‘´Â· ğœ•ğ‘´
ğœ•Ë†ğ‘º
.
The term ğœ•ğ‘´
ğœ•Ë†ğ‘ºrepresents the Jacobian matrix of the rasterization
process, which maps changes in edge parameters to changes in
the mask tensor. This Jacobian matrix is computed efficiently using Algorithm 4. In our implementation, as in the Interpolate
function in line 10, we choose the gradient at the midpoint of each
segment as the representative gradient for that segment, as stated
in eq. (10). Once the Jacobian matrix is obtained, the gradient of the
loss function with respect to the edge parameters can be calculated
by multiplying the gradient of the loss function with respect to the
mask tensor, ğœ•ğ¿
ğœ•ğ‘´, by the Jacobian matrix ğœ•ğ‘´
ğœ•ğ‘º. This operation effectively backpropagates the gradients from the lithography model to
the edge parameters, enabling the optimization of the edge-based
OPC problem using gradient-based methods.
MRC aware optimization. One of the significant advantages of
EBOPC is the ability to obtain boundary information in real-time
during the optimization process, including edges, line ends, jogs,
notches, and other features. This is not possible with PBOPC. While

===== Page 5 =====

Algorithm 4 Transform Mask to Edge Gradients with Velocity
1: Input: Gradient matrix ğœ•ğ¿
ğœ•ğ‘´of size ğ‘ŠÃ— ğ»;
2: Input: Edge segments Ë†ğ‘ºof shape [ğ‘ğ‘ , 2, 2], where each edge is
defined by two points: start (ğ‘¥1,ğ‘¦1) and end (ğ‘¥2,ğ‘¦2);
3: Input: Pre-defined velocity list ğ‘½for each segment ğ’”ğ‘–;
4: Output: Edge gradients ğœ•ğ¿
ğœ•Ë†ğ‘ºof shape [ğ‘ğ‘ , 2, 2];
5: function ComputeEdgeGradients( ğœ•ğ¿
ğœ•ğ‘´, Ë†ğ‘º, ğ‘½)
6:
Initialize ğœ•ğ¿
ğœ•Ë†ğ‘ºto zeros of shape [ğ‘ğ‘ , 2, 2];
7:
for each segment ğ‘–in Ë†ğ‘ºdo
8:
(ğ‘£ğ‘¥, ğ‘£ğ‘¦) â†ğ‘½[ğ‘–];
9:
(ğ‘šğ‘¥,ğ‘šğ‘¦) â†[(ğ‘¥1 + ğ‘¥2)/2, (ğ‘¦1 + ğ‘¦2/2)];
â–·Midpoint
10:
ğ‘”mid â†Interpolate( ğœ•ğ¿
ğœ•ğ‘´,ğ‘šğ‘¥,ğ‘šğ‘¦);
11:
ğ’—ğ‘–â†[[ğ‘£ğ‘¥, ğ‘£ğ‘¦], [ğ‘£ğ‘¥, ğ‘£ğ‘¦]];
â–·Edge velocity
12:
ğœ•ğ¿
ğœ•Ë†ğ‘º[ğ‘–] â†ğ‘”mid Â· ğ’—ğ‘–;
13:
return ğœ•ğ¿
ğœ•Ë†ğ‘º;
level set-based methods can control boundaries globally, they lack
the ability to fine-tune specific locations. DiffOPC generates MRCclean optimization results by explicitly controlling manufacturability
through the velocity term ğ’—ğ‘–during optimization. Before the experiment, we divide the MRC edges into corresponding check pairs.
We classify mask rules into two categories: spacing checks, such
as minimum spacing, end of line spacing, jog to jog spacing, and
special notch spacing, and width checks, such as minimum width
check. Let ğœ¹denote the distance vector between check pairs. The
projection of ğœ¹along the y-direction is given by projğ‘¦ğœ¹= (ğœ¹Â· ğ’‹)ğ’‹,
where ğ’‹is the unit vector in the y-direction. The projection along the
x-direction is similarly defined. We achieve MRC-aware optimization
by controlling the velocity ğ’—ğ‘–as follows: ğ’—â€²
ğ‘–= ğ’—ğ‘–Â· ğœ(ğœ¹) where ğœ(ğœ¹)
is a function related to ğœ¹, defined as: ğœ(ğœ¹) = ğœ(ğ›½(proj ğœ¹âˆ’ğ·)). Here,
ğ·is a constant related to the mask rule, and proj is the projection
operator in either ğ‘¥or ğ‘¦direction, ğ›½is the steepness of sigmoid function ğœ(Â·). For the spacing and width check, when the distance proj ğœ¹
is smaller than ğ·, the velocity term rapidly decays to 0, preventing
further reduction in the distance. When proj ğœ¹is greater than ğ·,
ğœ(ğœ¹) returns to 1, allowing normal optimization to proceed without
interference. By controlling the velocity term based on the distance
between check pairs and mask rule constants, DiffOPC effectively
incorporates MRC constraints into the optimization process.
Lithography simulations. After obtaining the mask ğ‘´through
the rasterization process, we can utilize forward lithography model
in eq. (1) to calculate the aerial intensity ğ‘°. To obtain a continuousvalued printed image ğ’, we employ the sigmoid function ğœ(Â·) to
scale eq. (2) into a continuous space: ğ’= ğœ(ğ›¼(ğ‘°âˆ’ğ¼ğ‘¡â„)), where ğ›¼is
the steepness of ğœ(Â·), and ğ¼ğ‘¡â„is the threshold intensity value.
Objective function. We employ a combination of three loss functions: ğ¿2 loss, PVB loss, and EPE loss. The ğ¿2 loss and PVB loss are
defined as:
L2 = âˆ¥ğ’ğ‘›ğ‘œğ‘šâˆ’ğ‘»âˆ¥2, Lğ‘ğ‘£ğ‘= âˆ¥ğ’ğ‘šğ‘ğ‘¥âˆ’ğ’ğ‘šğ‘–ğ‘›âˆ¥2.
(6)
For the EPE loss, measured points are sampled along the boundary
of the target patterns, which includes a set of samples on horizontal
edges (HS) and a set of samples on vertical edges (VS). To map the
EPE loss to the continuous-value domain, we utilize the sigmoid
function. First, we calculate the distance between ğ’ğ‘›ğ‘œğ‘šand the
target pattern ğ‘»at the sampled points in VS and HS:
ğ‘«ğ‘ ğ‘¢ğ‘šğ‘–ğ‘—=
ï£±ï£´ï£´ï£²
ï£´ï£´ï£³
Ãğ‘—+ğ‘¡â„ğ‘’ğ‘ğ‘’
ğ‘˜=ğ‘—âˆ’ğ‘¡â„ğ‘’ğ‘ğ‘’ğ‘«ğ‘–ğ‘˜,
if (ğ‘–, ğ‘—) âˆˆHS,
Ãğ‘–+ğ‘¡â„ğ‘’ğ‘ğ‘’
ğ‘˜=ğ‘–âˆ’ğ‘¡â„ğ‘’ğ‘ğ‘’ğ‘«ğ‘˜ğ‘—,
if (ğ‘–, ğ‘—) âˆˆVS,
(7)
where ğ‘«ğ‘–ğ‘˜and ğ‘«ğ‘˜ğ‘—represent the distances between the printed
image and the target pattern at the corresponding locations, and
ğ‘¡â„ğ‘’ğ‘ğ‘’is a threshold value that determines the neighborhood size for
the distance calculation. ğ‘«is calculated by ğ‘«= (ğ’ğ‘›ğ‘œğ‘šâˆ’ğ‘»)2. Next,
we apply the sigmoid function to the calculated distances to obtain
the continuous-valued EPE loss:
Lğ‘’ğ‘ğ‘’=
âˆ‘ï¸
(ğ‘–,ğ‘—)âˆˆğ»ğ‘†âˆªğ‘‰ğ‘†
1
1 + exp(âˆ’ğ›¾ğ‘«ğ‘ ğ‘¢ğ‘šğ‘–ğ‘—) ,
(8)
where ğ›¾is a scaling factor that controls the steepness of the sigmoid
function. The total loss function is then defined as a weighted sum
of the three individual loss components:
Lğ‘¡ğ‘œğ‘¡ğ‘ğ‘™= ğ‘¤1L2 + ğ‘¤2Lğ‘ğ‘£ğ‘+ ğ‘¤3Lğ‘’ğ‘ğ‘’,
(9)
where ğ‘¤1, ğ‘¤2, and ğ‘¤3 are the weights assigned to each loss component. The use of the sigmoid function in the EPE loss allows for a
smooth integration of the EPE into the continuous-value domain,
enabling efficient gradient-based optimization.
For the backward pass, the gradients of the total loss function
with respect to the segment ğ’”ğ‘–are calculated using the chain rule:
ğœ•L
ğœ•ğ’”ğ‘–
= ğœ•L
ğœ•ğ‘´Â· ğœ•ğ‘´
ğœ•ğ’”ğ‘–
= ğœ•L
ğœ•ğ‘´
h
âŒŠğ‘¥ğ‘–1 + ğ‘¥ğ‘–2
2
âŒ‹, âŒŠğ‘¦ğ‘–1 + ğ‘¦ğ‘–2
2
âŒ‹
i
Â· ğ’—ğ‘–,
(10)
where âŒŠÂ·âŒ‹is floor operation and
ğœ•ğ¿
ğœ•ğ‘´= ğ‘¤1
ğœ•L2
ğœ•ğ‘´+ ğ‘¤2
ğœ•Lğ‘ğ‘£ğ‘
ğœ•ğ‘´
+ ğ‘¤3
ğœ•Lğ‘’ğ‘ğ‘’
ğœ•ğ‘´.
(11)
For the ğ¿2 loss, the gradient is calculated as:
ğœ•L2
ğœ•ğ‘´=2 Â· (ğ’âˆ’ğ‘») âŠ™ğœ•ğ’
ğœ•ğ‘´
=2ğ›¼Â·

ğ‘¯â€² âŠ—

(ğ’âˆ’ğ‘») âŠ™ğ’âŠ™(1 âˆ’ğ’) âŠ™ ğ‘´âŠ—ğ‘¯âˆ—
+(ğ‘¯â€²)âˆ—âŠ—[(ğ’âˆ’ğ‘») âŠ™ğ’âŠ™(1 âˆ’ğ’) âŠ™(ğ‘´âŠ—ğ‘¯)]
	
,
(12)
where the ğ‘¯â€² is the flipped kernel set ğ‘¯, and the ğ‘¯âˆ—is the conjugate
of ğ‘¯. Similarly, for the PVB loss, the gradient is calculated as:
ğœ•ğ¿ğ‘ğ‘£ğ‘
ğœ•ğ‘´
= 2 Ã— (ğ’ğ‘šğ‘–ğ‘›âˆ’ğ’ğ‘šğ‘ğ‘¥) âŠ™
 ğœ•ğ’ğ‘šğ‘–ğ‘›
ğœ•ğ‘´
âˆ’ğœ•ğ’ğ‘šğ‘ğ‘¥
ğœ•ğ‘´

.
(13)
The derivation of ğœ•ğ’ğ‘šğ‘–ğ‘›
ğœ•ğ‘´
and ğœ•ğ’ğ‘šğ‘ğ‘¥
ğœ•ğ‘´
is similar to that of ğœ•ğ’
ğœ•ğ‘´in
eq. (12). For the EPE loss, the gradient is calculated by summarizing
the gradients at the measure points (ğ‘–, ğ‘—):
ğœ•Lğ‘’ğ‘ğ‘’
ğœ•ğ‘´
=
âˆ‘ï¸
(ğ‘–,ğ‘—)âˆˆğ»ğ‘†âˆªğ‘‰ğ‘†
ğœ•Lğ‘’ğ‘ğ‘’
ğœ•ğ‘«ğ‘ ğ‘¢ğ‘šğ‘–ğ‘—
Â·
ğœ•ğ‘«ğ‘ ğ‘¢ğ‘šğ‘–ğ‘—
ğœ•ğ‘´
,
(14)
where
ğœ•Lğ‘’ğ‘ğ‘’
ğœ•ğ‘«ğ‘ ğ‘¢ğ‘šğ‘–ğ‘—= ğ›¾Â·
1
1+exp(âˆ’ğ›¾ğ‘«ğ‘ ğ‘¢ğ‘šğ‘–ğ‘—) (1 âˆ’
1
1+exp(âˆ’ğ›¾ğ‘«ğ‘ ğ‘¢ğ‘šğ‘–ğ‘—) ), (15)
and
ğœ•ğ‘«ğ‘ ğ‘¢ğ‘šğ‘–ğ‘—
ğœ•ğ‘´
=
ï£±ï£´ï£´ï£²
ï£´ï£´ï£³
Ãğ‘—+ğ‘¡â„ğ‘’ğ‘ğ‘’
ğ‘˜=ğ‘—âˆ’ğ‘¡â„ğ‘’ğ‘ğ‘’
ğœ•ğ‘«ğ‘–ğ‘˜
ğœ•ğ‘´,
if (ğ‘–, ğ‘—) âˆˆHS,
Ãğ‘–+ğ‘¡â„ğ‘’ğ‘ğ‘’
ğ‘˜=ğ‘–âˆ’ğ‘¡â„ğ‘’ğ‘ğ‘’
ğœ•ğ‘«ğ‘˜ğ‘—
ğœ•ğ‘´,
if (ğ‘–, ğ‘—) âˆˆVS,
(16)

===== Page 6 =====

with ğœ•ğ‘«ğ‘–ğ‘—
ğœ•ğ‘´calculated as:
ğœ•ğ·ğ‘–ğ‘—
ğœ•ğ‘´= ğœ• ğ’ğ‘–ğ‘—âˆ’ğ‘»ğ‘–ğ‘—
2
ğœ•ğ‘´
= 2(ğ’ğ‘–ğ‘—âˆ’ğ‘»ğ‘–ğ‘—) Â· ğœ•ğ’ğ‘–ğ‘—
ğœ•ğ‘´.
(17)
The detailed derivation of ğœ•ğ’ğ‘–ğ‘—
ğœ•ğ‘´can be found in eq. (12).
SRAF generation. SRAFs in lithography enhance sub-resolution
element printability by modifying diffraction and interference patterns in photoresist, leading to widened process windows, improved
resolution, depth of focus, and reduced line edge roughness. The
primary distinction among prior works lies in their handling of
SRAFs. In level set-based ILT methods, the implicit function ğœ™is
tied to the primary pattern, preventing the generation of SRAFs
during optimization. Conversely, pixel-based ILT methods like [14]
can generate SRAFs during mask optimization due to their higher degree of freedom. However, pixel-based ILT cannot impose rule-based
constraints on SRAFs, causing their growth to rely solely on gradients. This improves printability but can increase MRC violations
and hotspots. To address these issues, we propose a two-stage SRAF
optimization algorithm. The first stage involves efficient SRAF seed
generation using gradient contours, and the second stage employs
a differentiable edge-based optimization for the generated SRAFs.
This approach effectively avoids the problems of missing SRAFs in
level set-based methods and violations in pixel-based SRAFs.
Gradient Contour-based SRAF Seed Generation: During the optimization process, we observe that certain regions near the main
pattern exhibit gradients that flip the mask value, changing it from
0 to 1. However, since the edge-based segments do not include these
regions, they remain at 0. Combining continuous transmission mask
(CTM) [19] theory and the results from [14], we conclude that these
gradients can contribute to SRAF generation. As depicted in Figure 4(a), the contour line of the mask gradient map shows the position
of the extreme gradient points and indicates the gradient drop rate.
The position of the extreme points can guide SRAF placement, while
the gradient information can guide the subsequent SRAF cleanup
process. The implementation involves extending the existing mask
by a certain distance related to the mask rules to create a SRAF
forbidden region. As illustrated in Figure 4(a), gradient contour lines
are drawn outside the SRAF forbidden region. The extreme points
and the corresponding contour aspect ratios are used as the center of
the SRAF seeds. The initial SRAF minimum width/length is set to a
fixed value, and the shape and placement of the SRAF are determined
based on the aspect ratio. This step does not require precise SRAF
generation; it only needs to determine the initial position and aspect
ratio.
Differentiable Edge-based SRAF Optimization: In the second stage,
the generated seeds illustrated in Figure 4(a) are processed using the
Algorithm 1 segmentation method to create new segments, which
are then added to the main optimization process. The SRAFs are
optimized together with the mask. To accelerate the SRAF optimization process, we adopt a multi-resolution strategy similar to [14].
SRAF seeds are generated at low resolution, and then the seeds and
mask are refined in high resolution for more precise optimization.
Sample results are shown in Figure 4(b). The proposed two-stage
SRAF optimization algorithm enables the generation of SRAFs that
SRAF 
Forbidden 
Region
Initial
SRAF
Seeds
Gradient map & Initial SRAFs
(a)
Final mask and SRAFs
(b)
Figure 4: DiffOPC SRAF insertion and optimization.
enhance printability while minimizing MRC violations. We conducted a comprehensive comparison of DiffOPC, ILTs, and EBOPC
in Table 1.
4
Experimental Results
In our implementation, we set ğ‘ğ‘˜= 24 for the SOCS approximation. The parameters ğ›¼= ğ›½= ğ›¾= 50, ğ‘¤1 = 1,ğ‘¤2 = 0.9,ğ‘¤3 = 100.
The default segment length is set to 80 nm. The lithography recipe
is provided by the ICCAD 2013 [18] contest evaluation package. The
mask fracturing tool is implemented based on a GPU-accelerated
rectangular decomposition algorithm [20]. The entire framework
is written in PyTorch and tested on an Nvidia RTX 3090 GPU. The
mask rule check (MRC) is performed using KLayout. DiffOPC is
tested on both metal layer and via layer designs. The metal layer
evaluation designs for 32 nm M1 layout designs are from [18], and
larger layouts from [14] for the same process node. The via layer
evaluation designs are adopted from [21], containing ten 2ğœ‡ğ‘šÃ— 2ğœ‡ğ‘š
clips with different numbers of 70ğ‘›ğ‘šÃ— 70ğ‘›ğ‘švia patterns. SRAF
seeds are generated in a low resolution of 512 Ã— 512 and optimized
at a resolution of 2048 Ã— 2048.
4.1
Experimental Results on Metal Layer
Comparison with ILT. Table 2 compares the performance of our
proposed DiffOPC framework with state-of-the-art (SOTA) ILT approaches, namely NeuralILT [10] and MultiILT [14], on the ICCAD13
benchmark. The comparison is based on key metrics such as L2 (ğ‘›ğ‘š2),
PVB (ğ‘›ğ‘š2), EPE (ğ‘›ğ‘š), number of shots, and turnaround time (TAT,
seconds). DiffOPC demonstrates superior performance, achieving
an average L2 of 28280, which is 1.5% and 27% lower than MultiILT
and NeuralILT, respectively. Attributed to the utilization of EPE loss
introduced in eq. (8), DiffOPC achieves lower EPE, with an average
of 2.2, representing a 19% and 71% reduction compared to MultiILT
and NeuralILT. Moreover, DiffOPC requires significantly fewer shots
per case, with an average of 106.1 shots, representing a 62% and 81%
reduction compared to MultiILT and NeuralILT, which translates to
lower manufacturing costs. These results highlight the effectiveness
of DiffOPC in generating mask patterns with improved printability while maintaining better manufacturability compared to ILT
methods. As mentioned in Section 1 and illustrated in Figure 5, ILT
approaches are prone to introducing MRC violations, which do not
meet industrial requirements. We also present the post-MRC results
for MultiILT in the "Post-MRC" column, where the TAT includes
both the ILT runtime and the post-processing time for cleaning mask
rule violations. It is noteworthy that the post-MRC stage for MultiILT leads to a significant performance degradation, evident from the

===== Page 7 =====

Table 1: DiffOPC compared with ILTs and EBOPC.
Level set-based ILT
Pixel-based ILT
MEEF-based EBOPC
DiffOPC
Shape
Free-form (more smooth)
Free-form (sharp corners)
Manhattan shape
Manhattan shape
Gradient update:
Level set function
Mask transmission
Edge move distance
Edge segment position
Optimization
Gradient descent
Gradient descent
Newtonâ€™s method
Gradient descent
SRAF
None
Automatic generation
Pre-placed SRAF
SRAF co-optimization
MRC clean?
No
No
Yes
Yes
EPE loss
None
None
Yes
Yes
Table 2: Comparison with ILT methods on ICCAD13 dataset.
ICCADâ€™20 NeuralILT [10]
DACâ€™23 MultiILT [14]
MultiILT (Post-MRC) [14]
DiffOPC
L2
PVB
EPE #shots
TAT
L2
PVB
EPE #shots TAT
L2
PVB
EPE #shots
TAT
L2
PVB
EPE #shots
TAT
c1
215344
50795
63695
8
743
13.57
40779
50661
3
307
3.49 45940 54949
7
275
18.42
38661 55156
3
107
10.62
c2
169280
36969
60232
3
571
14.37
34201
44322
2
186
3.47 37035 45085
3
167
13.64
29548 45610
0
104
10.65
c3
213504
94447
85358
52
791
9.72
66486
71527
22
308
3.47 79751 82213
35
261
18.71
64706 93773
19
121
11.52
c4
82560
17420
32287
2
209
10.40
10942
21500
0
233
3.47 13111 32330
1
204
19.24
12054 25053
0
80
6.04
c5
281958
42337
65536
3
631
10.04
30231
51277
0
374
3.47 39236 60069
1
296
13.23
31774 56966
0
129
6.72
c6
286234
39601
59247
5
745
11.11
30741
44982
0
365
3.47 37493 56581
1
300
16.14
31791 52997
0
129
10.33
c7
229149
25424
50109
0
354
9.67
17101
40294
0
196
3.50 19133 48156
0
155
13.57
17847 45791
0
96
6.59
c8
128544
15588
25826
0
467
11.81
11935
20357
0
243
3.47 13917 28910
0
201
22.09
11641 23172
0
78
6.52
c9
317581
52304
68650
2
653
9.68
35805
57930
0
435
3.50 45659 70023
1
387
14.51
36595 65732
0
141
10.11
c10 102400
10153
22443
0
423
11.46
8825
18470
0
114
3.48
9715
22979
0
88
18.23
8184
17923
0
76
5.12
Average
38503.8 53338.3
7.5
558.7
11.18 28704.6 42132.0
2.7
276.1
3.48 34099 50130
4.9
233.4
16.78 28280 48217
2.2
106.1
8.42
Ratio
1.36
1.11
3.41
5.27
1.33
1.02
0.87
1.23
2.60
0.41
1.21
1.04
2.23
2.20
1.99
1.00
1.00
1.00
1.00
1.00
Table 3: Comparison with ILT methods on larger dataset.
ICCADâ€™20 NeuralILT [10]
DACâ€™23 MultiILT [14]
MultiILT (Post-MRC) [14]
DiffOPC
L2
PVB
EPE #shots TAT
L2
PVB
EPE #shots TAT
L2
PVB
EPE #shots
TAT
L2
PVB
EPE #shots
TAT
L1
494560
79933
120577
12
669
20
64020
93060
3
628
3.48
80403
101194
11
529
22.66
57178
97979
3
247
11.49
L2
448496
86995
104266
15
556
12
52072
84733
1
553
3.46
72261
91673
8
491
18.07
63288
85388
2
109
11.89
L3
492720
133281
152718
70
766
15
95174
116687
30
641
3.49 118860 125013
65
564
20.49
81120 120828
22
267
14.69
L4
361776
43797
92137
0
455
14
33076
67839
1
523
3.47
41526
76582
2
479
21.43
31531
70713
0
177
8.53
L5
561174
69521
122115
3
808
19
55013
100120
0
670
3.46
76176
111861
6
528
16.00
53484 102675
0
258
7.69
L6
565450
73790
117359
2
764
19
57386
94863
0
670
3.45
76644
108667
5
501
18.74
56581
97980
0
293
13.21
L7
445365
49031
92320
0
531
19
32947
73799
0
648
3.45
40838
84006
0
503
18.19
42091
84836
0
222
9.91
L8
407760
47409
84971
0
478
16
41265
67797
0
493
3.48
43475
73021
0
426
20.49
32482
68687
0
198
8.53
L9
596797
93922
115028
5
614
14
70385
108998
0
541
3.48
84857
120426
4
514
18.04
60748 111449
0
226
11.44
L10 381616
28028
80127
0
452
19
30091
62206
0
546
3.46
36767
67807
0
452
20.95
28334
63274
0
188
8.78
Average
70570.7 108161.8 10.7
609.3
16.7 53142.9 87010.2
3.5
591.3
3.47
67181
96025
10.1
498.7
19.51 50684
90381
2.7
218.5
10.62
Ratio
1.39
1.20
3.96
2.79
1.57
1.05
0.96
1.30
2.71
0.33
1.33
1.06
3.74
2.28
1.84
1.00
1.00
1.00
1.00
1.00
increased average values of L2, PVB, EPE, and TAT compared to the
original MultiILT results. The results of DiffOPC outperform all metrics of ILT in the post-MRC stage. This indicates that ILT-generated
patterns may not optimize as desired and could introduce more violations, prolonging processing times due to MRC. In contrast, DiffOPC
maintains superior performance without extra post-processing steps,
highlighting its robustness and efficiency in generating high-quality,
manufacturable mask patterns meeting industrial standards.
Large dataset. To further validate the robustness and scalability
of our proposed DiffOPC framework, we conduct experiments on a
larger dataset and compare its performance with SOTA methods in
Table 3. The results demonstrate that DiffOPC consistently outperforms the other methods, highlighting its effectiveness in handling
complex and diverse patterns. DiffOPC achieves an average L2 of
50684, which is 4.7% and 28.2% lower than MultiILT and NeuralILT,
NeuralILT [10]
MultiILT [14]
DiffOPC
0
10
20
30
8.9
11.7
0
18.6
25.4
0
4
22
0
Avg. MRC violations
ICCAD13
Large Dataset
Via
Figure 5: MRC violations across methods and datasets
respectively. Moreover, it exhibits superior performance in terms
of EPE, with an average EPE of 2.7, representing a 23% and 75%
reduction over MultiILT and NeuralILT. Notably, DiffOPC requires
significantly fewer shots per case, with an average of 218.5 shots,
which is 63% and 64% lower than MultiILT and NeuralILT. As observed in the previous experiment, the post-MRC stage for MultiILT
leads to a deterioration in performance. This further underscores

===== Page 8 =====

Table 4: Comparison with traditional MEEF EBOPC on ICCAD
2013 benchmark.
MEEF-based EBOPC [2]
DiffOPC w./o. SRAFs
L2
PVB
EPE #shots TAT
L2
PVB
EPE #shots TAT
c1
52310
60296
14
67
13
42177
57981
4
79
5.53
c2
36498
52124
2
60
11
31198
50474
2
58
5.35
c3
90824
103100
59
87
12
71643
81219
26
92
6.52
c4
12144
30663
2
34
9
14771
32059
0
30
3.29
c5
31832
60792
0
84
14
33986
61796
0
89
5.24
c6
30612
55751
0
98
14
33578
56752
0
85
5.44
c7
15343
48968
0
59
11
17928
48886
0
60
4.16
c8
11851
26149
0
33
9
12805
25942
0
43
3.82
c9
38858
71288
0
93
14
39543
73183
0
97
4.70
c10
6562
21024
0
26
9
8167
21332
0
19
3.39
Avg. 32683.4 53015.5 7.7
64.1
11.6 30579.6 50962.4 3.2
65.2
4.74
Ratio
1.07
1.04
2.33
0.98
2.44
1.00
1.00
1.00
1.00
1.00
the limitations of ILT-based methods in generating manufacturable
patterns that comply with industrial requirements.
Comparison with MEEF-based EBOPC on ICCAD2013 benchmark. To provide a fair comparison between proposed DiffOPC and
the traditional MEEF-based EBOPC method [2], we evaluate both
approaches on GPU without the inclusion of SRAFs. The results in
Table 4 demonstrate that DiffOPC consistently outperforms MEEFEBOPC. On average, DiffOPC achieves an L2 of 30579.6, which is 6.5%
lower than MEEF-EBOPC. Similarly, DiffOPC exhibits lower average
PVB, EPE, and TAT with 3.9%, 58%, and 59% respectively. These
findings highlight the superior printability of the mask patterns
generated by DiffOPC compared to the traditional MEEF-EBOPC.
It is worth noting that MEEF-EBOPC struggles to handle complex
patterns. The limitation is evident from the results presented in Table 4, where MEEF-EBOPC exhibits particularly high EPE values
for complex test cases such as c3 (EPE = 59) compared to simpler
cases like c10 (EPE = 0). In contrast, DiffOPC demonstrates robust
performance across all test cases while maintaining a competitive
shot count compared to MEEF-EBOPC.
4.2
Experimental Results on Via Layer
In Table 5, we evaluate the performance of DiffOPC on the via
layer against SOTA ILT and EBOPC methods, including a commercial
tool, Calibre [22].
Comparison with ILT methods. DiffOPC outperforms ILT methods in terms of L2 and EPE, achieving the lowest values of 3957 and
13.5, respectively. Notably, DiffOPC achieves these improvements
while maintaining a significantly lower shot count (9.7 shots on
average), which is approximately 1/20th of the shot count required
by [14] (225 shots).
Comparison with EBOPC methods. Among the EBOPC methods,
DiffOPC demonstrates superior performance, achieving the lowest L2 (3957), EPE (13.5), and TAT (2.8 seconds) compared to the
commercial Calibre tool and the MEEF-based approach.
4.3
Ablation Study
Efficiency of CUDA-accelerated ray casting rasterization. We
compare the runtime of our CUDA-accelerated ray casting rasterization approach with the traditional EBOPC method based on indexing
and the find-then-move strategy. For a clip size of 2ğœ‡ğ‘šÃ—2ğœ‡ğ‘š, a single
Table 5: Result comparison on via layer.
ILT
EBOPC
NILT [10] MILT [14] MILT(MRC) [14] Calibre [22] MEEF [2] DiffOPC
L2
4629
3963
4385
4136
4371
3957
PVB
11367
10478
11157
10648
11272
10880
âˆ—EPE
22
14.2
18.7
14.2
18.2
13.5
Shots
219
225
191
8.5
6.2
9.7
TAT
5.7
1.5
5.4
8.2
4.6
2.8
âˆ—EPE: EPE threshold set to 1 ğ‘›ğ‘š.
forward rasterization step in DiffOPC takes 16 milliseconds, while
the traditional method requires 196 milliseconds, representing a
12.3Ã— speedup achieved by our CUDA ray casting implementation.
Ablation Study on Segment Length. Segment length in DiffOPC
also impacts optimization performance. In an ablation study using
the ICCAD 2013 benchmark, segment lengths of 60ğ‘›ğ‘š, 80ğ‘›ğ‘š, and
100ğ‘›ğ‘šresulted in EPE of 2.6, 2.2, and 2.8, with runtimes of 8.95, 8.42,
and 6.92 seconds. This shows that optimal segment length selection
can enhance OPC performance. Future work could explore adaptive segment length strategies, adjusting lengths based on pattern
complexity and optimization progress for better performance.
4.4
Summary of Experimental Results
The experimental results on both metal and via layers demonstrate DiffOPCâ€™s superiority over SOTA ILT, post-MRC ILT and
EBOPC methods in terms of printability, manufacturability, and
cost-efficiency. On metal layers, DiffOPC consistently outperforms
SOTA ILT methods, exhibiting reduced EPE and shot count, along
with lower manufacturing costs, while maintaining competitive TAT.
The proposed framework eliminates the need for additional postprocessing to address MRC violations, making it an efficient and
reliable edge-based OPC solution for large-scale OPC tasks. On via
layers, DiffOPC achieves the best performance in L2, EPE, and TAT
among EBOPC methods, surpassing even the commercial Calibre
tool. Compared to ILT methods, DiffOPC shows the lowest L2 and
EPE values while significantly reducing the number of shots, leading to lower manufacturing costs and improved throughput. These
results highlight DiffOPCâ€™s enhanced printability, pattern fidelity,
and computational efficiency.
5
Conclusion
We propose DiffOPC, a differentiable edge-based OPC framework that bridges the gap between the superior manufacturability
of EBOPC and the enhanced performance of ILT. By leveraging a
CUDA-accelerated ray casting algorithm, DiffOPC enables a differentiable rasterization process that allows gradients to propagate
through the lithography model, facilitating the efficient optimization of edge segment positions. This innovative approach results in
significant improvements in key metrics such as L2 and EPE while
maintaining an exceptionally low shot count, leading to substantially reduced manufacturing costs. Moreover, DiffOPC incorporates
an efficient SRAF generation method, which seamlessly integrates
SRAF with the main pattern optimization for a holistic and effective
OPC solution. Experimental results highlight DiffOPCâ€™s superior
performance and efficiency over SOTA EBOPC and ILT methods,
making it a promising advancement in semiconductor technologies.

===== Page 9 =====

References
[1] O. W. Otto, J. G. Garofalo, K. K. Low et al., â€œAutomated optical proximity correction:
a rules-based approach,â€ in Proc. SPIE, 1994, pp. 278â€“293.
[2] J. Lei, L. Hong, G. Lippincott, and J. Word, â€œModel-based opc using the meef matrix
ii,â€ in Optical Microlithography XXVII, vol. 9052.
SPIE, 2014, pp. 170â€“178.
[3] J.-R. Gao, X. Xu, B. Yu, and D. Z. Pan, â€œMOSAIC: Mask optimizing solution with
process window aware inverse correction,â€ in Proc. DAC, 2014, pp. 52:1â€“52:6.
[4] T. E. Brist and J. A. Torres, â€œModel-assisted placement of subresolution assist
features: Experimental results,â€ in Proc. SPIE, vol. 5042, 2003, pp. 99â€“106.
[5] X. Xu, Y. Lin, M. Li, T. Matsunawa, S. Nojima, C. Kodama, T. Kotani, and D. Z.
Pan, â€œSubresolution assist feature generation with supervised data learning,â€ IEEE
TCAD, vol. 37, no. 6, pp. 1225â€“1236, 2017.
[6] M. B. Alawieh, Y. Lin, Z. Zhang, M. Li, Q. Huang, and D. Z. Pan, â€œGAN-SRAF:
Sub-resolution assist feature generation using conditional generative adversarial
networks,â€ in Proc. DAC, 2019, pp. 149:1â€“149:6.
[7] H. Geng, W. Zhong, H. Yang, Y. Ma, J. Mitra, and B. Yu, â€œSraf insertion via supervised dictionary learning,â€ IEEE TCAD, 2020.
[8] H. Yang, S. Li, Y. Ma, B. Yu, and E. F. Young, â€œGAN-OPC: Mask optimization with
lithography-guided generative adversarial nets,â€ in Proc. DAC, 2018, pp. 131:1â€“
131:6.
[9] G. Chen, W. Chen, Y. Ma, H. Yang, and B. Yu, â€œDAMO: Deep agile mask optimization
for full chip scale,â€ in Proc. ICCAD, 2020.
[10] B. Jiang, L. Liu, Y. Ma, H. Zhang, E. F. Y. Young, and B. Yu, â€œNeural-ILT: Migrating
ILT to nerual networks for mask printability and complexity co-optimizatonâ€,â€ in
Proc. ICCAD, 2020.
[11] W. Zhao, X. Yao, Z. Yu, G. Chen, Y. Ma, B. Yu, and M. D. F. Wong, â€œAdaOPC: A selfadaptive mask optimization framework for real design patterns,â€ in Proc. ICCAD,
2022.
[12] B. Zhu, S. Zheng, Z. Yu, G. Chen, Y. Ma, F. Yang, B. Yu, and M. D. F. Wong, â€œL2O-ILT:
Learning to optimize inverse lithography techniques,â€ IEEE TCAD, vol. 43, no. 3,
pp. 944â€“955, 2024.
[13] X. Zhang, S. Zheng, G. Chen, B. Zhu, H. Xu, and B. Yu, â€œFracturing-aware curvilinear ilt via circular e-beam mask writer,â€ 2024.
[14] S. Sun, F. Yang, B. Yu, L. Shang, and X. Zeng, â€œEfficient ILT via multi-level lithography simulation,â€ in Proc. DAC, 2023.
[15] Z. Yu, G. Chen, Y. Ma, and B. Yu, â€œA GPU-enabled level set method for mask
optimization,â€ in Proc. DATE, 2021.
[16] G. Chen, Z. Yu, H. Liu, Y. Ma, and B. Yu, â€œDevelSet: Deep neural level set for instant
mask optimization,â€ in Proc. ICCAD, 2021.
[17] W. Lv, S. Liu, Q. Xia, X. Wu, Y. Shen, and E. Y. Lam, â€œLevel-set-based inverse lithography for mask synthesis using the conjugate gradient and an optimal time step,â€
Journal of Vacuum Science & Technology B, Nanotechnology and Microelectronics:
Materials, Processing, Measurement, and Phenomena, vol. 31, no. 4, p. 041605, 2013.
[18] S. Banerjee, Z. Li, and S. R. Nassif, â€œICCAD-2013 CAD contest in mask optimization
and benchmark suite,â€ in Proc. ICCAD, 2013, pp. 271â€“274.
[19] Z. Yu, P. Liao, Y. Ma, B. Yu, and M. D. F. Wong, â€œCTM-SRAF: Continuous transmission mask-based constraint-aware subresolution assist feature generation,â€ IEEE
TCAD, vol. 42, no. 10, pp. 3402â€“3411, 2023.
[20] J. F. Chango, C. A. Navarro, and M. A. GonzÃ¡lez-Montenegro, â€œGpu-accelerated
rectangular decomposition for sound propagation modeling in 2d,â€ in 2019 38th
International Conference of the Chilean Computer Science Society (SCCC), 2019.
[21] S. Zheng, H. Yang, B. Zhu, B. Yu, and M. D. Wong, â€œLithoBench: Benchmarking AI
computational lithography for semiconductor manufacturing,â€ in Proc. NeurIPS,
2023.
[22] â€œCalibre Design Solutions, Siemens,â€ https://eda.sw.siemens.com/en-US/ic/calibredesign/.
